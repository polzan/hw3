\documentclass[a4paper,oneside]{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}

\usepackage[margin=2.54cm]{geometry}
\usepackage{amsmath}
\usepackage{siunitx}
\usepackage{listings}
\usepackage{color}
\usepackage{textcomp}
\usepackage{graphicx}
\usepackage{xr}
\usepackage{subcaption}
%\usepackage{changepage}
\usepackage[section]{placeins}
%\usepackage{hyperref}

%\strictpagecheck
\externaldocument{hw3_code}

\definecolor{matlabgreen}{RGB}{28,172,0}
\definecolor{matlablilas}{RGB}{170,55,241}

\newcommand{\includecode}[1]{\lstinputlisting[caption={\ttfamily #1.m},label={lst:#1}]{matlab/#1.m}}
\newcommand{\inlinecode}[1]{\lstinline[basicstyle=\ttfamily,keywordstyle={},stringstyle={},commentstyle={\itshape}]{#1}}

\renewcommand{\vec}[1]{\underline{#1}}
\renewcommand{\Re}[1]{\operatorname{Re}\left[#1\right]}
\newcommand{\E}[1]{\operatorname{E}\left[#1\right]}
\newcommand{\norm}[1]{\left\lVert#1\right\rVert}
\newcommand{\abs}[1]{\left|#1\right|}
\newcommand{\F}[1]{\operatorname{\mathcal{F}}\left[#1\right]}
\newcommand{\ceil}[1]{\left\lceil#1\right\rceil}
\newcommand{\floor}[1]{\left\lfloor#1\right\rfloor}
\newcommand{\Prob}[1]{\operatorname{P}\left[#1\right]}
\newcommand{\ProbC}[2]{\operatorname{P}\left[#1\middle|#2\right]}
\newcommand{\ind}[1]{\operatorname{\mathbbm{1}}\left\{#1\right\}}
\DeclareMathOperator*{\argmin}{argmin}
\newcommand{\distr}[0]{\sim}
\newcommand{\unif}[1]{\mathcal{U}_{#1}}

\newcommand{\vsigma}[0]{\vec{\sigma}}

\author{Enrico Polo \and Riccardo Zanol}
\title{Homework 3}

\begin{document}
\lstset{
  language=Matlab,
  basicstyle={\ttfamily \footnotesize},
  breaklines=true,
  morekeywords={true,false,warning,xlim,ylim},
  keywordstyle=\color{blue},
  stringstyle=\color{matlablilas},
  commentstyle={\color{matlabgreen} \itshape},
  numberstyle={\ttfamily \tiny},
  frame=leftline,
  showstringspaces=false,
  numbers=left,
  upquote=true,
}
\maketitle
\section{Transmitter}
In the transmitter we generate the sequence of symbols $a_k$ by
producing a uniformly distributed sequnce of bits twice as long and
mapping each pair of bits to a symbol of the QPSK constellation $
\mathcal{A} = \{(1+j),(1-j),(-1-j),(-1+j)\}$. Then we upsample $a_k$
by a factor of 4 and filter it using the transfer function
\begin{equation}
  Q_c(z) = \frac{\beta z^{-10}}{1 - \alpha z^{-1}}
\end{equation}
that models the {\color{red} combination of the modulator filter and
  the channel}.  Since we will need it to have a finite length,
because the matched filter would otherwise not be causal, we truncate
its impulse response at $n=33$ (when $n \geq 34$, $q_c(nT/4) \leq
5\cdot10^{-5}$). In Fig.~\ref{plot:qc} we plot $q_c$ and in
Fig.~\ref{plot:Qf} there is the corresponding frequency response.
\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.7\textwidth]{matlab/plot_qc}
  \caption{Impulse response of the combination of the modulator and
    the channel}
  \label{plot:qc}
\end{figure}
\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.7\textwidth]{matlab/plot_Qf}
  \caption{Frequency response of the combination of the modulator and
    the channel}
  \label{plot:Qf}
\end{figure}

We then add {\color{red} the channel noise} $w_c(nT/4)$, assumed to be
a complex gaussian with power spectral density $\mathcal{P}_{w_c}(f) =
N_0$ in the band of the signal $S_c(nT/4)$. The noise power and PSD
can be obtained from the SNR:
\begin{align}
  \Gamma &= \frac{\sigma^2_a E_{q_c}}{\sigma^2_{w_c}} \\
  N_0 &= \sigma^2_{w_c}\frac{T}{4}
\end{align}
where $E_{q_c}$ is the energy of the filter $q_c$ and the power of the
symbol sequence is $\sigma^2_a = 2$.

The signal that gets to each one of the following receivers is
$r_c(nT/4) = S_c(nT/4) + w_c(nT/4)$.
\section{Viterbi}
In the Viterbi receiver we use the same filter $g_M(nT/4) = q_c^*((\overline{t_0} - n)T/4)$ of
sections~\ref{sec:le}~and~\ref{sec:dfe}, matched to the response of
the transmitter and the channel $q_c$, {\color{red} to maximize the
  SNR before the equalizer} and we also sample in the same way
starting at $t_0 = \overline{t_0}\frac{T}{4} = 33\frac{T}{4}$ with
period $T$.

Before applying the Viterbi algorithm we design a filter $c$ with the
method based on the Wiener filter already used in
section~\ref{sec:dfe}:
\begin{align}
  \vec{p}_p &= \sigma^2_ah^*_{D-p} \\
  R_{p,q} &= \sigma^2_a\left( \sum_{j=-N_1}^{N_2}h_jh^*_{j-(p-q)} - \sum_{j=1}^{M_2}h_{j+D-q}h^*_{j+D-p} \right) + r_{\tilde{w}}(p-q) \\
    \vec{c} &= R^{-1} \vec{p}
\end{align}
where $h = q_c * g_M$ and $r_{\tilde{w}}(n) = N_0 r_{g_M}(nT)$. The
parameters that we choose are the same as in section \ref{sec:dfe}:
$M1 = M2 = 3$, $D=1$ {\color{red} and $N1 = N2 = 8$ }.

The overall system response before the Viterbi detector is $\psi(kT) =
(q_c * g_M * c)_{(kT)}$ and it is shown in Fig.~\ref{plot:psi_dfe}.
\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.7\textwidth]{matlab/plot_psi_dfe}
  \caption{Overall system response $\psi(kT)$}
  \label{plot:psi_dfe}
\end{figure}
We can see that the filter $c$ has eliminated the effect of the
precursors, so the Viterbi algorithm only has to take into account the
three postcursors of $\psi$: its parameters will be $L_1 = 0$, $L_2 =
M2 = 3$ and, since the peak is shifted by $1T$, we set $D=1$.

To implement the Viterbi algorithm we first define the states
\begin{equation}
  \vec{s}_k = (a_k,a_{k-1}, a_{k-2}) \in \mathcal{S} = \{ \vec{\sigma}_1, \vec{\sigma}_2, \dots \vec{\sigma}_{64} \}
\end{equation}
that can be any combination of three symbols taken from the
constellation $\mathcal{A}$, then we precompute:
\begin{itemize}
  \item if it is possible to have a transition from a state
    $\vec{s}_{k-1} = \vec{\sigma}_i$ to the successive state
    $\vec{s}_{k} = \vec{\sigma}_j$, for every pair of states
    $\vec{\sigma}_j$, $\vec{\sigma}_i$    
\item the value of the sample we would receive if
  $(\vec{s}_k,\vec{s}_{k-1})$ were equal to $(\vsigma_j, \vsigma_i)$
  \begin{equation}
    u_k = f(\vec{\sigma}_j, \vec{\sigma}_i) =
    \sum_{n=-L_1}^{L_2}\psi_{n+D}a_{k-n}
  \end{equation} wherever a transition from $\vec{\sigma}_i$ to $\vec{\sigma}_j$ is
  possible.
\end{itemize}
We then initialize the path metric values at state $k=-1$
\begin{equation}
  \Gamma(\vec{s}_{k-1} = \vec{\sigma}_j) = 0 \qquad j=1,2,\dots64
\end{equation}
because we have no information on the state of the system, so each one
is equally likely, and start to process the input signal $\rho_k$
sample by sample following the Viterbi algorithm. At every iteration
we compute for each state $\sigma_j$:
\begin{itemize}
\item the branch metrics
  \begin{equation}
    \abs{\rho_k - u_k}^2 \qquad \forall u_k = f(\vsigma_j,\vsigma_i)
  \end{equation}
    where it is possible to move from $\vsigma_i$ to $\vsigma_j$,
  \item the corresponding path metrics
    \begin{equation}
      \Gamma(\vec{s}_{k-1} = \vec{\sigma}_i) + \abs{\rho_k - u_k}^2 \qquad \forall \vsigma_i ,
    \end{equation}
  \item the path metric that we assign to state $\vsigma_j$ in the
    current iteration $k$
    \begin{equation}
      \Gamma(\vec{s}_k = \vec{\sigma}_j) = \min_{\vsigma_i} \Gamma(\vec{s}_{k-1} = \vec{\sigma}_i) + \abs{\rho_k - u_k}^2
    \end{equation}
    and we also store the state that minimizes the path metric,
    ${\vsigma_i}_{opt}$, in the survivor sequence
    \begin{equation}
      \mathcal{L}(\vec{s}_k = \vsigma_j) = (\mathcal{L}(\vec{s}_{k-1} = {\vsigma_i}_{opt}), \vsigma_j) .
    \end{equation}
\end{itemize}
After a number of iterations equal to the maximum desired depth of the
trellis diagram, $K_d$ we select
\begin{equation}
  {\vsigma_j}_{opt} = \argmin_{\vsigma_j} \Gamma(\vec{s}_{K_d-1} = \vec{\sigma}_j)
\end{equation}
and follow the survivor sequence $\mathcal{L}(\vec{s}_{K_d-1} =
{\vsigma_j}_{opt})$ backward until we reach the first state,
{\color{red}which is the most likely to be the actual state of the
  system at time $k-K_d+1$. Finally we can get the detected symbol
  $\hat{a}_{k+K_d-1+D}$ from the first component of the state}, which
is shifted with respect to the original symbol sequence $a_k$ because
the algorithm waits for the trellis diagram to be full before
detecting the first symbol. {\color{red}There is also a delay of $D$
  samples introduced by the filter $c$}.

After trying some values we pick a trellis depth equal to ten times
the length of the state: $K_d = 30$. Since the input signal is a lot
longer than $K_d$, when the trellis diagram is full and we get a new
sample $\rho_k$, we delete the oldest values from the path metrics and
the survivor sequences. Since the path metrics are non-decreasing at a
certain point they will overflow, so we shift them back every 5000
samples by subtracting the smallest value from all the others.

As can also be seen in Fig.~\ref{plot:pe_all}, with a SNR of 11 dB we
get a symbol error probability $P_e = 3.77 \cdot 10^{-4}$.
\section{MaxLogMAP}

\section{Symbol error comparison}
\begin{figure}[htbp]
  \centering
  \includegraphics[width=\textwidth]{matlab/pe_plot}
  \caption{Comparison of the symbol error with different receivers}
  \label{plot:pe_all}
\end{figure}
\end{document}
